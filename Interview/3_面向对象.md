## 类和对象、`this`指针

C语言代码中，写的是各种各样的函数的定义，用`struct`来自定义类型

而在C++中，则是各种各样的类。类也是用于自定义类型的，将类描述为**实体的抽象类型**

用OOP思想来解决实际问题时，需要明白问题场景中有哪些实体，例如在校园人员信息管理系统中，就有：老师、学生、辅导员、研究生……，这些实体都要抽象出一个类，在计算机中的==**类**==来代表现实世界中**<u>实体的抽象类型</u>**

在问题场景中找到实体后，根据该实体的属性和行为两方面，可以得到这个实体的ADT（abstract data type），根据这个ADT从而转换为计算机中的类。实体的属性在类中称为数据成员/成员变量，行为在类中称为成员函数/成员方法

当使用类来实例化对象时，对象在逻辑意义上代表现实中的实体，因此对象是会占内存空间的

==**总结**==：<u>C++进行OOP编程，首先需要分析问题场景中各种各样的实体，通过分析实体的属性和行为，得到实体的ADT，通过ADT输出这个类，类代表的是实体的抽象数据类型，当用类实例化对象后，对象才代表具体的实体</u>

> ==**OOP语言的四大特征是什么**==
>
> 抽象、封装/隐藏、继承、多态
>
> 其中，封装通过类中的访问限定符（`public`公有的）、（`protected`保护的）、（`private`私有的）

例如：用类来描述一个商品实体，商品有商品名称、商品单价、商品数量……这些都是商品的属性，商品的行为有：

```cpp
const int NAME_LEN = 20;
class CGoods ==> 商品的抽象数据类型
{
public: // 给外部提供公有的成员方法，来访问私有的属性
    // 进行商品数据的初始化
    void init(const char *name, double price, int amount);
    // 打印商品信息
    void show();
    // 给成员变量提供一个getXXX或setXXX的方法
    void setName(char *name) {strcpy(_name, name);}
    const char *getName() { 
        //用const修饰返回值，即指针的指向，是为了防止外部变量通过指针修改内部的值
    	return _name;
    }
    … … … …
        
private: // 属性一般都是私有的变量
    char _name[NAME_LEN];
    double _price;
    int _amount;
};

int main() 
{
    CGoods good; // 类实例化了一个对象
    good.init("面包", 10.0， 200);
    	// "面包"是常量字符串，不允许用普通指针来接收，必须用常指针
    good.show();
    
    return 0;
}
```

抽象数据类型是不占内存空间的，使用该类型定义的对象，才会占用内存空间，上面的对象`good`存储在栈上

类方法的实现，可以在类体内直接提供：类体内实现的方法，==自动处理成`inline`内联函数==；也可以在类外定义，但是需要在方法名前加作用域，通过作用域限定符与方法名连接，这种方式定义的方法，就是普通的方法，调用的时候就是标准的函数调用，如果想变成内联，就在前面加`inline`

```cpp
void CGoods::init(const char *name, double price, int amount) {
    strcpy(_name, name);
    _price = price;
    _amount = amount;
}
void CGoods::show() {
    std::cout << "name: " _name << ", price: " << _price
        << ", amount: " << _amount << std::endl;
}
```

用类来实例化对象，由对象来调用方法。因为成员函数是对实体行为的表示，不指定具体的对象，光说行为是没有意义的

因此，==成员函数的访问一定依赖于对象，由对象来访问成员方法==

类中，既有数据成员，又有成员函数。<u>**对象的内存大小**只和**数据成员**有关</u>，计算方法和结构体一样，先找占用内存最长的数据成员，以它为内存字节对齐方式，从而计算出总的对象的大小

类型可以定义无数的对象，每个对象都有自己的数据成员，但是它们共享一套成员函数。这些方法编译成指令是放在代码段上的

当使用对象调用该类的方法时，该方法时如何知道要处理哪个对象的信息？—— `this`指针

其实质上在调用方法的时候，会将调用该方法的对象地址也作为参数传入该成员函数中。因此，编译器在编译类的成员函数时，会给所有的成员方法加上`className *this`这个参数，用于接收调用该方法的对象的地址。所以，也会在该成员函数中给数据成员加上`this`指针，表示该对象指向的数据成员

<u>`this`指针的作用就是在成员方法中区分，当前类的不同对象，要处理哪个对象的数据</u>

一个类能够产生对个对象，每个对象都有一份自己的成员变量，但是同一个类型的对象是共享一套成员函数的，在这套成员函数中，通过`this`指针来进行区分不同的对象，操作不同对象的数据成员

成员函数一经编译，函数的参数都会添加一个`this`指针，用于接收调用该方法的对象

> `struct`和`class`都可以用来定义类，两者的不同之处在于
>
> | 特性             | `struct`                                                 | `class`                                                      |
> | ---------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
> | 默认成员访问权限 | public                                                   | private                                                      |
> | 默认继承访问权限 | public                                                   | private                                                      |
> | 使用场景         | 通常用于定义简单的聚合数据结构，结构体更偏向于存储数据。 | 更倾向于定义具有封装性和复杂行为的类，通常包括方法和数据成员。 |



## 构造函数和析构函数

构造函数的作用是对象成员变量的初始化操作（开辟资源）；析构函数的作用是释放对象成员变量占用的外部资源（外部堆内存）

**构造函数的名字和类名一样，且没有返回值，在定义对象时自动调用；析构函数的名字是在类名前加`~`，也没有返回值**

构造函数和析构函数能够代替成员变量的初始化和对象出作用域前的释放对象占用的外部资源的操作

定义一个对象，会进行这些操作：

1. 开辟内存
2. 调用构造函数

一般说，构造函数调用完，对象就产生了。即，先开辟内存，内存有了之后，类的数据成员也就有了，但是它们的值还不合法，而调用完构造函数后，数据成员会被合法的初始化，就说对象产生了。对象是逻辑上的概念，实际并不存在于内存上，物理上也没有对象的概念

出对象作用域时，栈上的对象会依次自动进行析构：<u>先构造的后析构，后构造的先析构</u>。调用析构函数后，就说对象不存在了

注意，析构函数是不带参数，因此类中的析构函数只能有一个；而构造函数是可以带参数的，因此可以提供多个构造函数，叫做构造函数的重载，在调用时，编译器会根据传入的参数的个数和类型来匹配最适合的版本

当没有提供任何构造函数的时候，编译器会生成默认构造（即不带任何参数）和默认析构，它们是空函数。但是当有显式构造函数时候，编译器就不会再提供默认的构造函数了

构造函数是无法选择的，它是在定义对象的时候，根据定义的方式编译器自己匹配的构造函数，而析构函数是可以自己调用的，调用析构的时候，对象也还是存在的，但是，析构函数调用以后，虽然说对象不存在了，但是内存还在，因为是栈上的对象，其内存是在出作用域后有编译器自动回收的。

在调用该析构函数后，不要再调用对象的方法了，如果调用的话，从语法角度来说，编译是可以的，但是析构函数已经释放了外部的资源（如果有的话），因此可能会非法访问内存（访问已释放的资源）

> `delete`会先调用析构，然后再`free`

==**总结**==

- 构造函数：

    ​	定义对象时，自动调用；可以重载；构造完成，对象产生

- 析构函数：

    ​	不带参数，因此不能重载，只有一个析构函数；析构完成，对象不存在

`.data`数据段的对象是程序启动时构造，程序结束时析构；堆上的对象是`new`的时候构造，`delete`时析构；栈上的对象是进入函数到其定义的地方构造，函数结束对象析构



## 对象的深拷贝和浅拷贝

对象内存只包含数据成员，因此对象的内存大小**可能大于其所有数据成员大小之和**，并且**是其最大数据成员对齐要求的整数倍**

同构造和析构一样，当没有显式提供拷贝构造函数的时候，编译器也会提供一个默认的拷贝构造，会通过一个已经存在的同类型的对象来产生一个同类型的新对象。它会进行**<u>内存的拷贝</u>**

```cpp
ExampleClass ec;
ExampleClass ec2 = ec; // ExampleClass ec2(ec); 这两种方式一模一样
```

上述语句，会将`ec`内存中的值，直接赋值给`ec2`。因此如果`ExampleClass`类的数据成员中，有指针变量，即存储的是一个地址，那么对象`ec`和对象`ec2`的这个数据成员，将指向同一块堆内存

在这种情况下，由于`ec2`是后生成的，会先析构，在释放外部资源时，会将指针变量指向的那块堆内存释放掉，并且将该变量赋为`NULL`；而先生成的`ec`对象，后析构时，也会去释放那块堆内存，由于那片内存已经被释放了，所以`ec`的指针变量成了野指针，它析构时，释放野指针从而导致出现**未定义行为**，并可能引发程序崩溃、内存损坏或其他难以调试的问题。

这个就是所谓的==**浅拷贝**==，即对象直接进行内存拷贝。对象并不是进行浅拷贝就一定有错。而这里错误是因为这里对象有成员变量（特别是指针），指向了对象内存之外的外部资源，当发生浅拷贝的时候，多个对象的指针指向了同一个资源，这样在第一个对象析构的时候，就释放了资源，而在后面的对象析构时，还要去释放已经释放的资源时候就会出错，同一个资源不能释放多次

==**对象默认的拷贝构造是直接做内存的数据拷贝**，浅拷贝不一定有错，但是对象如果占用外部资源，那么浅拷贝就会出现问题！==

基于上面的情况，正确的做法是进行==**深拷贝**==，即对象的成员变量不仅仅需要赋值，对于占用外部资源的的数据成员，还需要单独开辟一块外部资源，让新对象的指针指向这块资源。这样每个对象的指针指向自己独有的一份外部资源，在析构时各自析构自己的内存，互不干扰，就不会存在释放野指针的操作了

总得来说，就是一个对象的成员变量中有指针，在构造的时候，这个指针指向了对象外部的一块堆内存，那么这个对象在调用默认的拷贝构造时，就会进行浅拷贝，这是一定会发生问题的。因此，此时不能依赖编译器产生的默认拷贝构造函数（进行直接内存数据拷贝）了，必须自定义一个

```cpp
// 假设这个数据成员是一个char*
ExampleClass(const ExampleClass &other) {
    // _memberPtr = other._memberPtr; // 浅拷贝
    // 下面是深拷贝
    _memberPtr = new char[strlen(other._memberPtr) + 1]; // 分配新的内存
    strcpy(_memberPtr, other._memberPtr); // 复制原对象的数据到新分配的内层中
    _otherMember = other._otherMember;
    // 需要确保不会发生资源共享（每个对象都有自己独立的资源
}
```

在OOP（Object-Oriented Programming）中对于数据的拷贝一般用`for`循环，而不会用`memcpy()`或者是`realloc`，除非能够明确处理的数据没有占用外部资源（浅拷贝不会出错），那么就是可以使用内存拷贝或者内存扩容；否则，如果数据中存在指向外部资源指针，在使用以上两个函数时就会发生浅拷贝，从而在析构时引发问题，因此使用`for`循环更为安全（如下），因为在循环体中是赋值操作，没有生成新的对象，`=`左右两边都是已经存在的对象

```cpp
for (int i = 0; i < _size; ++i)
    _mem[i] = _memberPtr[i];
```

如果没有显式的定义拷贝赋值运算符，编译器会提供一个默认的拷贝赋值运算符重载，也是做直接内存拷贝，也会和默认的拷贝构造函数一样，在析构的时候出现问题，即也发生了浅拷贝的问题

`ec2 = ec1;`直接将`ec1`赋值给`ec2`，做直接的内存赋值，（假设`ec1`先定义），这样在`ec2`先析构，在其析构时就会释放其数据成员`_memberPtr`指向的内存，而这块内存同时也被`ec1._memberPtr`指向，因此在之后析构`ec1`是，就会出现`double free`的问题；同时由于是直接的内存赋值，原来`ec2.memberPtr`指向的内存也找不到了，就会发生内存泄漏的情况

因此，在对象的浅拷贝会发生问题的时候，不仅仅需要自定义拷贝构造函数，还需要自定义拷贝赋值运算符和析构函数，以确保对象的正确复制与释放。这遵循的是 **C++的“三/五法则”**（**Rule of Three/Five**）

> **C++的“三/五法则**：
>
> - **Rule of Three**（三法则）
>
>     如果一个类**显式**定义了 **拷贝构造函数**，那么通常还需要显式定义：
>
>     1. **拷贝构造函数**（`ClassName(const ClassName& other)`）：确保正确复制对象。
>     2. **拷贝赋值运算符**（`ClassName& operator=(const ClassName& other)`）：避免浅拷贝和资源泄漏。
>     3. **析构函数**（`~ClassName()`）：确保正确释放资源，防止内存泄漏。
>
> - **Rule of Five**（五法则）
>
>     C++11 引入了 **移动语义**，所以如果一个类需要定义 **拷贝构造函数**，那么通常还需要考虑 **移动构造函数** 和 **移动赋值运算符**，这就是**五法则**：
>
>     1. **拷贝构造函数**（`ClassName(const ClassName& other)`）
>     2. **拷贝赋值运算符**（`ClassName& operator=(const ClassName& other)`）
>     3. **析构函数**（`~ClassName()`）
>     4. **移动构造函数**（`ClassName(ClassName&& other) noexcept`）
>     5. **移动赋值运算符**（`ClassName& operator=(ClassName&& other) noexcept`）

在自定义拷贝赋值运算符重载中，正确的逻辑应该是：

```cpp
ExampleClass& operator=(const ExampleClass& rhs) {
    if (this == &rhs)
        return *this; // 处理自赋值
    delete[] _memberPtr; // 释放当前对象的旧资源，避免内存泄漏
    _memberPter = new char[strlen(rhs._memberPtr) + 1]; // 分配新内存
    strcpy(_memberPtr, rhs._memberPtr);
    _otherMember = other._otherMember; // 复制内容
    return *this; // 返回当前对象的引用，从而支持连锁赋值 a = b = c;
}
```

拷贝赋值运算符重载和拷贝构造的功能基本上是一样的，但是，赋值的前提是`=`左右两边的对象都是存在的，因此拷贝赋值运算符重载需要多一个释放原来内存的逻辑

==**总结**==：

对象在发生默认的拷贝和赋值时，使用的是编译器自动生成的，会做直接内存拷贝，即浅拷贝，浅拷贝不一定有问题，但是，当对象有数据成员指向外部资源时，浅拷贝就会出现问题，会让两个对象中的数据成员指向同一块资源；在这两个对象析构时候，就会去释放同一块内存，从而出现`double free`的问题。此时就需要显式的自定义拷贝构造和拷贝赋值运算符重载函数，进行深拷贝



## 应用

### 编写类String的构造函数、析构函数和赋值函数

```cpp
class String 
{
public:
    String(){}
    String(const char *str = nullptr) {
    	if (str) {
            _data = new char[strlen(str) + 1];
        	strcpy(_data, str);
        } else {
            _data = new char[1];
            _data = '\0';
        }
        // 这样初始化，无论外面传进来的是什么，_data都不为空
        // 同时避免了在后面的函数中无需判断_data是否为空
    }
    String(const String &other) {
        _data = new char[strlen(other._data) + 1];
        strcpy(_data, other._data);
    }
    String& operator=(const String &rhs) {
        if (&rhs == this)
            return *this;
        delete[] _data;
        _data = new char[strlen(other._data) + 1];
        strcpy(_data, other._data);
        return *this;
    }
    ~String() {
        delete[] _data;
        _data = nullptr; // 防止野指针出现
    }
private:
    char *_data;
};
```

### 循环队列

```cpp
class Queue
{
public:
    Queue(int size = DEFAULT)
        :_size(size)
    {
     	_que = new int[size]; 
        _front = _rear = 0;
    }
    Queue(const Queue& other) {
        _front = other._front;
        _rear = other._rear;
        _size = other._size;
        _que = new int[_size]; 
        for (int i = _front; i != _rear; i = (i + 1) % _size)
            _que[i] = other._que[i];
    }
    Queue& operator=(const Queue& rhs) {
        if (this == &rhs)
            return *this;
        delete[] _que;
        _front = rhs._front;
        _rear = rhs._rear;
        _size = rhs._size;
        _que = new int[_size]; 
        for (int i = _front; i != _rear; i = (i + 1) % _size)
            _que[i] = rhs._que[i];
    }
    ~Queue() {
        delete[] _que;
        _que = nullptr;
        _front = _rear = _size = 0;
    }
                       
    void push(int val) {
        if (full())
            resize();
        _que[_rear] = val;
        _rear = (_rear + 1) % _size;
    }                   
	void pop() {
        if (empty())
            return;
        _front = (_front + 1) % _size;
    }
	int top() {
        return _que[_front];
    }
	bool full() {
        return (_rear + 1) % size == _front;
    }
	bool empty() {
        return _front == _rear;
    }
                      
private:
    int *_que;
    int _front;
    int _rear;
    int _size;
                      
	void resize() {
         int newQue = new int[_size * 2];
        int idx = 0;
        for (int i = _front; i != _rear; i = (i + 1) % _size)
            newQue[idx++] = _que[i];
        delete[] _que;
        _que = newQue;
        _front = 0;
        _rear = idx;
        _size *= 2;
    } 
}
```



## 构造函数的初始化列表

==**组合关系**==：`a part of`，也就是说在B类中，有一个数据成员是A类型的，即该数据成员是一个**成员对象**，那么就说A类和B类之间是组合关系，<u>A is a part of B</u>，

在OOP中，定义一个对象，却没有指定它的构造方式的时候，它使用的就是该类的默认构造函数。编译器本身会给类提供一个构造函数，但是前提是没有显式的自定义构造函数

在 C++ 中，**构造函数的初始化列表（Initializer List）** 是一种高效的对象初始化方式，尤其适用于**成员变量**和**基类**的初始化。初始化列表可以避免额外的赋值操作，提高性能，并且对 `const`、`引用` 和 `不可默认构造的成员变量` 具有重要作用。

```cpp
class ClassName {
public:
    ClassName(参数列表) : 成员变量1(值1), 成员变量2(值2), ... { 
        // 构造函数体
    }
};
/* 一般会把 
 : 成员变量1(值1), 成员变量2(值2), ...
 上面这部分的内容另启一行，写在构造函数参数列表的下面一行。
 这部分内容，称为构造函数的初始化列表
*/
```

先执行的是构造函数的初始化列表，后执行构造函数体

> **为什么使用初始化列表？**
>
> - 提高性能能
>
>     如果在构造函数体内赋值，类成员会经历**两次初始化**：
>
>     1. 先调用默认构造函数初始化成员变量（如果有的话）。
>     2. 然后在构造函数体内使用赋值运算符进行赋值。
>
>     而**使用初始化列表直接初始化成员变量**，则只进行**一次初始化**，避免了额外的赋值操作，提高效率。

注意，构造函数的初始化列表只能写简单的初始化，像`char[]`类型的赋值（需要调用`strcpy`）应该放到函数体中进行

**适用场景**

1. `const` 或 `引用` 成员变量

    `const` 和 `引用` 变量**必须在声明时初始化**，不能在构造函数体内赋值，因此**必须使用初始化列表**

    ```cpp
    class Test {
    private:
        const int a;
        int& b;  // 引用变量
    public:
        Test(int x, int& y) : a(x), b(y) {}  // 必须使用初始化列表
    };
    /**********************************************************/
    public:
        Test(int x) { 
            a = x;  // ❌错误，const 变量不能在构造函数内赋值
        }
    ```

2. 类成员是对象，且该对象没有默认构造函数

    如果类的成员是一个**没有默认构造函数**的对象，必须在初始化列表中**显式调用它的构造函数**。

    ```cpp
    class A {
    public:
        A(int x) { cout << "A Constructor: " << x << endl; }
    };
    
    class B {
    private:
        A a;  // A 没有默认构造函数
    public:
        // 必须在初始化列表中初始化 a
        B(int y) : a(y) {
            cout << "B Constructor" << endl;
        }
    };
    
    int main() {
        B obj(10);
        return 0;
    }
    // 如果不使用初始化列表，编译会失败，因为 A 没有默认构造函数，无法默认初始化。
    ```

3. 继承时初始化基类

    在派生类的构造函数中，应该使用初始化列表来**显式调用基类的构造函数**，否则会调用基类的默认构造函数（如果有的话）。

    ```cpp
    class Base {
    public:
        Base(int x) { cout << "Base Constructor: " << x << endl; }
    };
    
    class Derived : public Base {
    public:
        // 显式调用 Base 的构造函数
        Derived(int y) : Base(y) {
            cout << "Derived Constructor" << endl;
        }
    };
    
    int main() {
        Derived obj(20);
        return 0;
    }
    /*
    如果不使用初始化列表，编译器会尝试调用 Base 的默认构造函数（如果存在），但 Base 可能没有默认构造函数，导致编译错误。
    */
    ```

==**注意**==：<font color='red'>初始化列表的**执行顺序**并不是按列表的顺序，而是按**成员变量在类中的声明顺序**！</font>

在 C++ 中，构造函数可以使用**初始化列表**或**构造函数体**来对成员变量进行初始化：

- 在构造函数体内赋值，成员变量会经历**两步操作**：

    1. **默认初始化**（调用默认构造函数，若类型是基础类型，则值未定义）。
    2. **赋值**（使用 `=` 重新赋值）。

    **可以使用构造函数体赋值的情况**：

    - 当成员变量**必须先经过某些计算**再初始化时。

- **初始化列表是直接初始化**，只进行**一步操作**。

     **使用初始化列表：** 数据成员 直接被赋值，避免了先默认构造再赋值的额外开销。

    ✅ **必须使用初始化列表的情况**：

    - **`const` 成员变量**
    - **`&`（引用）成员变量**
    - **类成员是对象，且该对象没有默认构造函数**
    - **继承时初始化基类**

    🚀 **推荐使用初始化列表的情况**：

    - 任何可以直接初始化的成员变量，避免默认构造后再赋值的额外开销，提高效率。

对于内置类型来说，上面两种类型的赋值方式的汇编代码是一样的；但是对于自定义类型来说就不同了，如果写在函数体中，该数据成员就是先用一个默认构造（无参）方式构造一个实例，然后再使用一个自定义的构造函数（带参）构造一个匿名的对象，然后使用*赋值运算符*进行赋值，这样一来情况就变得复杂了

| 方式           | 主要优点                                              | 主要缺点                     |
| -------------- | ----------------------------------------------------- | ---------------------------- |
| 初始化列表     | **效率高**，**避免额外赋值**，必须用于 `const` 和 `&` | 不能使用复杂逻辑             |
| 构造函数体赋值 | 可以先做复杂计算再赋值                                | **效率低**（多一次默认构造） |

**能用初始化列表就用初始化列表**，避免不必要的赋值，提高性能。**`const`、引用和无默认构造的成员变量必须用初始化列表**。**避免在构造函数体内赋值，除非初始化需要复杂计算**。



## 类的各种成员方法以及区别

> 普通的成员函数：（$\Longrightarrow$ 编译器会添加一个\*this形参变量）
>
> 1. 属于类的作用域
> 2. 调用该函数时，需要依赖一个对象（常对象是无法调用的）
> 3. 可以任意访问对象的私有成员变量

静态的数据成员，它在类中仅仅是声明，因此一定还需要在类外进行定义，并且初始化。它是由该类实例化的所有对象所共享的，因此它是不被算在对象的内存中的，它是存在数据段(`.bss`)中的

静态的成员函数，它是没有该类的`this`指针的，因此在调用它的时候，是不需要依赖对象的，直接通过类名加作用域限定符来调用即可。因此普通的成员函数和静态的成员函数，它们本质的区别就是，普通的成员函数需要通过对象来调用，因为它在==该函数被调用时==会产生`this`指针（而不是对象创建时），由编译器**隐式传递**给该函数的，接收当前对象的地址，必须使用对象来调用，才能将该对象的地址作为实参传入；而静态的成员函数不会产生this指针，也就无需接收一个对象的地址。

因此，如果一个函数访问的是一个类的所有对象共享的信息，最好将这个方法写成静态方法。并且静态方法中没有对象，因此，在该函数体中也是无法访问普通的数据成员的，只能访问那些不依赖对象的数据成员

> static静态成员函数：（$\Longrightarrow$ 不会生成this形参）
>
> 1. 属于类的作用域
> 2. 用类名作用域来调用方法
> 3. 可以任意访问对象的私有成员，仅限与不依赖对象的成员（只能调用其他的static 静态成员）

如果一个对象是被`const`修饰的，在使用该对象去调用普通的成员函数时会报错，==**本质原因**==还是因为在调用这个普通的成员函数时，编译器会添加一个this形参变量，在实参(`const`类名 \*)传递给形参(类名 *\)时，发生了隐式的类型转换，而这个转换是非法的

对于这种情况，正确的做法是给一个用`const`修饰的成员函数（即在原函数的参数列表后加`const`），这样编译器在给这个成员函数生成`this`指针的时候，就会生成`const 类名* this`，这样就能够成功的接收`const`修饰的对象了。而这个成员函数称为**常成员函数**，它与原来的普通成员函数构成重载关系（参数列表不同）

==只要是只读操作的成员函数，一律实现成`const`常成员函数==，这样普通对象可以调用，常对象也可以

> const 常成员函数：（$\Longrightarrow$ 编译器会添加一个 const \*this形参变量）
>
> 1. 属于类的作用域
> 2. 调用该函数时，需要依赖一个对象（普通对象或者常对象都可以）
> 3. 可以任意访问对象的私有成员变量，但是只能读，而不能写



## 指向类成员的指针

### 指向成员变量的指针

假设一个类中有一个普通的`int`型的数据成员，不能像普通的变量一样，用指针去指向

```cpp
int a = 10;
int *p = &a;

/*************************/
class ClassName {
public:
    int member;
};

int *ptr = &ClassName::member;
// error: 无法从 int ClassName::* 转换到 int *
```

这里没有指定`member`这个成员是属于哪个对象，抛开对象谈普通的数据成员，是没有意义的

根据上面的报错信息也可以知道，编译器认为`&ClassName::member`并不是一个普通的整型的指针，而是有类作用的指针，因此在定义的时候也要加上类的作用域

```cpp
int ClassName::*ptr = &ClassName::member; // 明确告诉编译器，指针指向的是一个整型的变量，但不是全局的，而是ClassName这个类作用域里面的一个整型的变量
*ptr = 20; // error
```

在通过解引用访问`member`的时候，一定要加对象，脱离对象访问类的成员变量是没有意义的

```cpp
ClassName c1;
ClassName *c2 = new ClassName();

c1.*ptr = 20;
c2->*ptr = 30;

delete c2;
```

如果在`ClassName`类中有静态的成员变量，`static int mem`，对于这个变量则可以直接使用`int*`型的指针进行接收，`int *p = &ClassName::mem; *p = 40;`

### 指向成员函数的指针

```cpp
class ClassName {
public:
    void func() {}
    static void st_func() {}
};
```

还是跟上面的指向成员变量的指针一样

```cpp
void （*pfunc)() = &ClassName::func; 
// error: 无法从 void (__thiscall ClassName::*)(void) 转换为 void (__cdecl *)(void)
```

后面的`void (__cdecl *)(void)`是标准的C调用约定，这是一个**普通函数指针**的类型，指向一个返回类型为`void`、没有参数的普通函数。`__cdecl`是另一种调用约定，通常用于普通函数，并且不会像`__thiscall`那样隐式地传递`this`指针。

**`void (__thiscall ClassName::*)(void)`**: 这是一个**成员函数指针**的类型，它指向一个返回类型为`void`、没有参数的成员函数。`__thiscall`是调用约定，表示这是一个类成员函数，调用时会隐式地将`this`指针作为第一个参数传递给成员函数。

成员函数指针和普通函数指针在C++中是**不兼容**的。成员函数需要隐式地接收`this`指针（指向对象实例的指针），而普通函数则不需要。因此，它们的类型结构是不同的。具体来说，`void (__thiscall ClassName::*)(void)`是一个指向**类成员函数**的指针，它需要知道对象的上下文（即`this`指针）；而`void (__cdecl *)(void)`是一个普通函数指针，它不涉及对象上下文，因此它们的调用约定和签名不同，不能直接进行转换。

因此在定义指针的时候必须和上面的成员变量一样：

```cpp
void (ClassName::*pfunc)() = &ClassName::func; // 这样，告诉编译器，这个指针指向一个返回值是void 且无形参的函数，并且指向的是ClassName这个类里面的成员函数
```

因此在使用这个指针间接调用函数的时候，由于普通成员函数的调用需要依赖对象，所以在通过指针解引用调用该函数的时候，必须使用对象进行调用，否则调用是无法成功的

```cpp
c1.(*pfunc)();
```

对于定义函数指针指向类的`static`成员函数，则无需那么麻烦，可以只用普通的函数指针进行指向，在调用时也无需使用对象

```cpp
void （*pst)() = &ClassName::st_func; 
(*pst)();
```

